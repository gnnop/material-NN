from _common_data_preprocessing import *
import pickle
import math
import numpy as npx
import extended_atom_encoding
from prettyprint import prettyPrint


'''


Each line is a crystal in POSCAR format. Here are the indices and their meanings:
0:    generated by phonopy
1:    phonopy version
2-4:  the three axes of the relative coordinate system with
        respect to global Cartesian coordinates. Each element is three
        doubles separated by four spaces, and units in Angstroms
5:    a list of chemical symbols separated by spaces, each referring to an
        atom type present in the crystal. For example, Pb_6 Mo_2 O_10 Cl_4
        would have "Pb Mo O Cl" here.
6:    a list of integers separated by spaces, each referring to the number
        of atoms of the corresponding type in the crystal. For example,
        Pb_6 Mo_2 O_10 Cl_4 would have "6 2 10 4" here.
7:    "Cartesian" or "Direct", referring to the coordinate system used.
        Always Direct in this dataset
8+:   a list of doubles. Each group of three doubles is the coordinates of 
        each atom in the crystal, in the local coordinate system.

        For example (in the case of Pb_6 Mo_2 O_10 Cl_4): the first six elements
        would be the coordinates of the six Pb atoms, the next two would be the
        coordinates of the two Mo atoms, the next ten would be the coordinates of
        the ten O atoms, and the last four would be the coordinates of the four Cl
        atoms.

For example

b'generated by phonopy
1.0
9.8430000000000000    0.0000000000000000    0.0000000000000000
0.0000000000000000    9.8430000000000000    0.0000000000000000
0.0000000000000000    0.0000000000000000    9.8430000000000000
Au In
36   16
Direct
0.1650000000000000  0.1650000000000000  0.8350000000000000
0.1650000000000000  0.8350000000000000  0.1650000000000000
0.8350000000000000  0.1650000000000000  0.1650000000000000
0.8350000000000000  0.8350000000000000  0.8350000000000000
0.6759999999999999  0.6759999999999999  0.3240000000000000
0.6759999999999999  0.3240000000000001  0.6759999999999999
0.3240000000000001  0.6759999999999999  0.6759999999999999
0.3240000000000001  0.3240000000000001  0.3240000000000000
0.3990000000000000  0.3990000000000000  0.6010000000000000
0.3990000000000000  0.6010000000000000  0.3990000000000000
0.6010000000000000  0.3990000000000000  0.3990000000000000
0.6010000000000000  0.6010000000000000  0.6010000000000000
0.0000000000000000  0.0000000000000000  0.3660000000000000
0.0000000000000000  0.6340000000000000  0.0000000000000000
0.6340000000000000  0.0000000000000000  0.0000000000000000
0.0000000000000000  0.0000000000000000  0.6340000000000000
0.0000000000000000  0.3660000000000000  0.0000000000000000
0.3660000000000000  0.0000000000000000  0.0000000000000000
0.5000000000000000  0.5000000000000000  0.8610000000000001
0.5000000000000000  0.1389999999999999  0.5000000000000000
0.1389999999999999  0.5000000000000000  0.5000000000000000
0.5000000000000000  0.5000000000000000  0.1389999999999999
0.5000000000000000  0.8610000000000001  0.5000000000000000
0.8610000000000001  0.5000000000000000  0.5000000000000000
0.9620000000000000  0.6859999999999999  0.3140000000000001
0.6859999999999999  0.6859999999999999  0.0380000000000000
0.6859999999999999  0.9620000000000000  0.3140000000000001
0.9620000000000000  0.3140000000000001  0.6859999999999999
0.6859999999999999  0.3140000000000001  0.9620000000000000
0.6859999999999999  0.0380000000000000  0.6859999999999999
0.0380000000000000  0.6859999999999999  0.6859999999999999
0.3140000000000001  0.6859999999999999  0.9620000000000000
0.3140000000000001  0.9620000000000000  0.6859999999999999
0.0380000000000000  0.3140000000000001  0.3140000000000001
0.3140000000000001  0.3140000000000001  0.0380000000000000
0.3140000000000001  0.0380000000000000  0.3140000000000001
0.8870000000000000  0.8870000000000000  0.1130000000000000
0.8870000000000000  0.1130000000000000  0.8870000000000000
0.1130000000000000  0.8870000000000000  0.8870000000000000
0.1130000000000000  0.1130000000000000  0.1130000000000000
0.4540000000000000  0.1929999999999999  0.8070000000000001
0.1929999999999999  0.1929999999999999  0.5460000000000000
0.1929999999999999  0.4540000000000000  0.8070000000000001
0.4540000000000000  0.8070000000000001  0.1929999999999999
0.1929999999999999  0.8070000000000001  0.4540000000000000
0.1929999999999999  0.5460000000000000  0.1929999999999999
0.5460000000000000  0.1929999999999999  0.1929999999999999
0.8070000000000001  0.1929999999999999  0.4540000000000000
0.8070000000000001  0.4540000000000000  0.1929999999999999
0.5460000000000000  0.8070000000000001  0.8070000000000001
0.8070000000000001  0.8070000000000001  0.5460000000000000
0.8070000000000001  0.5460000000000000  0.8070000000000001
'


The data structure for training/inference is:
Global axis coordinates (90)
    x (30)
    y (30)
    z (30)
Atoms (667 + 347 + 187 + 187 + 187 + 187 = 1662)
    Atom Set 1 (27 + 16*40 = 667)
        Type    (27)
        Atom 1  (16)
            Exists? (1)
            Position (15)
                x (5)
                y (5)
                z (5)
        Atom 2  (16)
        Atom 3  (16)
        ...
        Atom 40 (16)
    Atom Set 2 (27 + 16*20 = 347)
        Type    (27)
        Atom 1  (16)
        Atom 2  (16)
        ...
        Atom 20 (16)
    Atom Set 3 (27 + 16*10 = 187)
        Type    (27)
        Atom 1  (16)
        Atom 2  (16)
        ...
        Atom 10 (16)
    Atom Set 4 (27 + 16*10 = 187)
        10 atoms
    Atom Set 5 (27 + 16*10 = 187)
        10 atoms
    Atom Set 6 (27 + 16*10 = 187)
        10 atoms
Space group (one-hot encoded) (230)
Is 1D? (1)
Is 2D? (1)
Is 3D? (1)



'''







def format(rFile, wFile, sym, topo):
    '''
    This function is the core of formatting the contents of a dataset.
    
    It accepts the following parameters:
    rFile: the file to read from
    wFile: the file to write to
    sym: the type of symmetries to classify by (f or c or n)
    topo: the type of topology to classify by (f or c)

    These parameters are automatically generated by cmd_line, 
    a utility function in _common_data_preprocessing.py
    '''

    # defined in _common_data_preprocessing.py

    # More configuration
    atomSets = [40, 24, 16, 12, 8, 6]
    relativeCoordinateLength = 5
    absoluteCoordinateLength = 10
    fourierFeaturesPeriodScale = 2
    sizeOfAtomType = len(extended_atom_encoding.get_atom_from_db(1))
    sizeOfAtomPosition = 1 + 3*relativeCoordinateLength # 1 for the existence of the atom, 3 Fourier Features representations of the relative coordinates
    sizeOfGlobalAxisCoordinates = 3*relativeCoordinateLength # 1 for the existence of the atom type, 3 Fourier Features representations of the absolute coordinates

    sizeOfProcessedOutput = (
          3 * absoluteCoordinateLength # globalAxisCoordinates
        + sizeOfAtomType * len(atomSets)     # atom types
        + sizeOfAtomPosition * sum(atomSets) # atom positions
    )


    # Utilities
    def getRelativeCoordinates(val):
        '''
        Given a relative (i.e. between 0 and 1) coordinate, 
        express that coordinate as a five-element array of 
        Fourier featuresthat because that representation may 
        be easier for neural networks to digest.

        Each element is a float between -1 and 1, corresponding to
        the result of the following function.

        y_i(x) = sin(2*pi*2^^i*x)

        In other words:
        y_0(x) = sin(2*pi  *x)
        y_1(x) = sin(2*pi*2*x)
        y_2(x) = sin(2*pi*4*x)
        ...

        This function is loosely inspired by the following paper:
            Fourier Features Let Networks Learn High Frequency Functions in Low Dimensional Domains
            by Matthew Tancik, Pratul P. Srinivasan, Ben Mildenhall, Sara Fridovich-Keil, Jonathan T. Barron, and Ren Ng
        '''

        return [
            math.sin(
                math.tau
                * fourierFeaturesPeriodScale**(i+1)
                * val
            ) 
            for i in range(relativeCoordinateLength)
        ]
    
    # end of getRelativeCoordinates

    def getAbsoluteCoordinates(val):
        '''
        An extension of getRelativeCoordinates: they both serve a similar function.
        Unlike getRelativeCoordinates, this function is designed to handle numbers greater than one.
        
        This function dedicates half of the array to the fractional part of the 
        number, and the other half to the integer part.
        '''

        initialPeriod = 2**int(absoluteCoordinateLength/2)
        return [
            math.sin(
                math.tau
                * fourierFeaturesPeriodScale**(i+1)
                / initialPeriod
                *val
            ) 
            for i in range(relativeCoordinateLength)
        ]
    
    # end of getAbsoluteCoordinates
            
    def flatten(nested_list):
        """Flattens a list of lists of arbitrary depth."""
        for item in nested_list:
            if isinstance(item, list):
                # If item is a list, recursively yield from flattened list
                yield from flatten(item)
            else:
                # If item is not a list, yield item
                yield item
    # end of flatten

    
    processedOutput = []
    processedLabels = []


    # Begin processing the file
    with open(rFile, 'r', newline='') as file:
        reader = csv.reader(file)


        # Each row is a crystal in POSCAR format and other data. Iterate through them to build the dataset.
        for row in reader:

            # The first element of the row is the POSCAR data
            # Split by newlines and remove leading/trailing whitespace
            # That way we get:
            #   0:    generated by phonopy
            #   1:    phonopy version
            #   2-4:  the three axes of the relative coordinate system with
            #           respect to global Cartesian coordinates. Each element is three
            #           doubles separated by four spaces, and units in Angstroms
            #   5:    a list of chemical symbols separated by spaces, each referring to an
            #           atom type present in the crystal. For example, Pb_6 Mo_2 O_10 Cl_4
            #           would have "Pb Mo O Cl" here.
            #   6:    a list of integers separated by spaces, each referring to the number
            #           of atoms of the corresponding type in the crystal. For example,
            #           Pb_6 Mo_2 O_10 Cl_4 would have "6 2 10 4" here.
            #   7:    "Cartesian" or "Direct", referring to the coordinate system used.
            #           Always Direct in this dataset
            #   8+:   each element is the coordinates of each atom in the crystal, in the
            #           local coordinate system. Each element is three doubles separated
            #           by two spaces, and units are arbitrary (but consistent with the axes).
            #           For example (in the case of Pb_6 Mo_2 O_10 Cl_4): the first six elements
            #           would be the coordinates of the six Pb atoms, the next two would be the
            #           coordinates of the two Mo atoms, the next ten would be the coordinates of
            #           the ten O atoms, and the last four would be the coordinates of the four Cl
            #           atoms.
            poscar = list(map(lambda a: a.strip(), row[0].split("\\n")))

            # Atoms
            atomNames  = poscar[5].split()
            # poscar[6] as numbers
            atomCounts = list(map(int, poscar[6].split()))
            numAtomTypes = len(atomNames)
            if numAtomTypes != len(atomCounts):
                raise Exception(f"Bogus data: there were {numAtomTypes} atom names and {len(atomCounts)} counts")

            # Make a list of dictionaries, where each dictionary represents an atom type and
            # contains its name and the coordinates of all the atoms of that type

            # POSCAR data has all coordinates for all atoms, sorted by atom type, so we 
            # need to iterate through the list of coordinates and assign them to the correct atom type
            allAtomCoordinates = poscar[8:]
            # Trim all non-numeric characters off of the ends of the string
            allAtomCoordinates = list(map(lambda a: re.sub(r'[^0-9. ]', '', a), allAtomCoordinates))
            # convert to tuples of three floats each
            allAtomCoordinates = list(map(lambda a: tuple(map(float, a.split())), allAtomCoordinates))  

            # Build a database of all the atoms in the crystal
            atoms = []
            atomIndex = 0
            for i in range(numAtomTypes):
                atomType = atomNames[i]
                atomCount = atomCounts[i]
                atomCoordinates = []
                for j in range(atomCount):
                    atomCoordinates.append(allAtomCoordinates[atomIndex])
                    atomIndex += 1
                atoms.append({
                    "type": atomType,
                    "coordinates": atomCoordinates
                })
            # Now atoms is a list.
            # Each element is a dictionary containing all atoms of one type.
            #   'type' is the name of the atom
            #   'coordinates' is a list. Each element is a three-tuple of floats, 
            #   corresponding to the coordinates of an atom of type 'type' in local space.

            # Sort atom types by their count
            atoms.sort(key=lambda a: len(a['coordinates']), reverse=True)

            # Now we have a list of atoms, sorted by the number of atoms of each type.
            # Give it a name in case we need to complain about it
            atomString = ""
            for i in range(numAtomTypes):
                atomString += f"{atoms[i]['type']}{len(atoms[i]['coordinates'])} "

            # Reject crystals with too many types of atoms
            if len(atoms) > numAtomTypes:
                print(f"Skipping {atoms} because it has too many atom types ({len(atoms)}, max is {numAtomTypes}). Here's the layout of the atoms:")
                prettyPrint(atoms)
                continue

            # Reject crystals that have too many atoms of any type
            shouldSkipAtom = -1
            for i in range(len(atoms)):
                if len(atoms[i]['coordinates']) > atomSets[i]:
                    shouldSkipAtom = i
                    break
            if shouldSkipAtom >= 0:
                print(f"Skipping {atomString} because it has too many {atoms[shouldSkipAtom]['type']} atoms ({len(atoms[shouldSkipAtom]['coordinates'])}, max is {atomSets[shouldSkipAtom]}). Here's the layout of the atoms:")
                prettyPrint(atoms)
                continue

            # temporary: dump everything into processedOutput
            # processedOutput.append({
            #     "name": atomString,
            #     "globalAxisCoordinates": outputGlobalAxisCoordinates,
            #     "atoms": atoms,
            #     "topology": row[4]
            # })

            

            # Global axis coordinates
            outputGlobalAxisCoordinates = [float(j) for i in poscar[2:5] for j in i.split()]
            # Apply Fourier features to the global axis coordinates
            outputGlobalAxisCoordinates = [getAbsoluteCoordinates(i) for i in outputGlobalAxisCoordinates]


            # Now we have a list of atoms, sorted by the number of atoms of each type.
            # Each atom has a name and a list of coordinates.
            # We need to convert this into a format that can be used by a neural network.
            outputAtoms = [] # To be all atom types and all atom positions as one array
            for i in range(len(atomSets)): # for each atom type

                # if the atom type doesn't exist, fill in the blanks and move on
                if i >= len(atoms):
                    outputAtoms.append([0]*sizeOfAtomType)
                    outputAtoms.append([0]*atomSets[i]*sizeOfAtomPosition)
                    continue

                # Atom type
                outputAtomType = extended_atom_encoding.get_atom_from_db(atoms[i]['type'])

                # Atom positions
                # Put all atom positions in a single list
                outputAtomPositions = [0]*atomSets[i]*sizeOfAtomPosition
                outputAtomPositionsSize = len(outputAtomPositions)
                for j in range(len(atoms[i]['coordinates'])):
                    # Does the atom exist?
                    outputAtom = [1]
                    # Apply Fourier features to the atom's coordinates
                    outputAtom += [getRelativeCoordinates(k) for k in atoms[i]['coordinates'][j]]
                    outputIndex = j*sizeOfAtomPosition
                    outputAtomPositions[outputIndex:outputIndex+sizeOfAtomPosition] = list(flatten(outputAtom))
                
                thisSetOfAtoms = [outputAtomType, outputAtomPositions]
                
                # Done with this atom type
                outputAtoms.append(thisSetOfAtoms)

            # Space group
            outputSpaceGroup = [0]*231
            outputSpaceGroup[int(row[2])] = 1

            # Is 1D? Is 2D? Is 3D?
            outputIs1D = [0] if 'Point' in row[6] else [1]
            outputIs2D = [0] if 'Line'  in row[6] else [1]
            outputIs3D = [0] if 'None'  in row[6] else [1]
            
            # Done with all atom types
            processedAtom = [outputGlobalAxisCoordinates, outputAtoms, outputSpaceGroup, outputIs1D, outputIs2D, outputIs3D]
            # Completely flatten the processedAtom list
            processedAtom = list(flatten(processedAtom))

            # Final sanity check: all arrays should be the same size.
            if len(processedOutput) > 0 and len(processedAtom) != len(processedOutput[0]):
                print(f"Skipping {atomString} because it has a different size ({len(processedAtom)} vs {len(processedOutput[0])}). Here's the layout of the atoms:")
                prettyPrint(atoms)
                raise Exception(f"Size mismatch: {len(processedAtom)} vs {len(processedOutput[0])}")
            
            # Add the processedAtom to the list of processedOutput
            processedOutput.append(processedAtom)
            processedLabels.append(convertTopoToIndex(row, topo))
        # end of for row (crystal) in reader

        print("\n"*5)
        print(f"Processed {len(processedOutput)} crystals. Here are the results:")
        prettyPrint(processedOutput, only_show_amount=5)

        processedOutput = np.array(processedOutput)
        processedLabels = np.array(processedLabels)
        print(f"Processed output shape: {processedOutput.shape}")
        print(f"Processed labels shape: {processedLabels.shape}")

        # Save the processed data to a file
        with open(wFile, 'wb') as wFile:
            pickle.dump({
                "data": processedOutput,
                "labels": processedLabels
            }, wFile)



cmd_line(format, "naive")